
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>config: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">LibraryManagement/config/config.go (0.0%)</option>
				
				<option value="file1">LibraryManagement/config/db.go (0.0%)</option>
				
				<option value="file2">LibraryManagement/controller/bookController.go (48.0%)</option>
				
				<option value="file3">LibraryManagement/controller/userController.go (100.0%)</option>
				
				<option value="file4">LibraryManagement/dao/bookDAO.go (96.2%)</option>
				
				<option value="file5">LibraryManagement/dao/userDAO.go (0.0%)</option>
				
				<option value="file6">LibraryManagement/main.go (0.0%)</option>
				
				<option value="file7">LibraryManagement/middleware/auth.go (0.0%)</option>
				
				<option value="file8">LibraryManagement/result/code.go (0.0%)</option>
				
				<option value="file9">LibraryManagement/result/result.go (0.0%)</option>
				
				<option value="file10">LibraryManagement/router/router.go (0.0%)</option>
				
				<option value="file11">LibraryManagement/service/bookService.go (0.0%)</option>
				
				<option value="file12">LibraryManagement/service/userService.go (78.1%)</option>
				
				<option value="file13">LibraryManagement/utils/jwt.go (90.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package config

import (
        "fmt"
        "os"

        "gopkg.in/yaml.v3"
)

type config struct {
        Server server `yaml:"server"`
        Db     db     `yaml:"db"`
}

type server struct {
        Port string `yaml:"port"`
}

type db struct {
        User     string `yaml:"user"`
        Password string `yaml:"password"`
        Host     string `yaml:"host"`
        Port     string `yaml:"port"`
        Db       string `yaml:"db"`
}

var Config *config

func LoadConfig(path string) error <span class="cov0" title="0">{
        data, err := os.ReadFile(path)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("无法读取配置文件: %w", err)
        }</span>

        <span class="cov0" title="0">if err := yaml.Unmarshal(data, &amp;Config); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("无法解析配置文件: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package config

import (
        "fmt"
        "log"

        "gorm.io/driver/mysql"
        "gorm.io/gorm"
)

var DB *gorm.DB

func SetupDBLink() error <span class="cov0" title="0">{
        dsn := fmt.Sprintf("%s:%s@tcp(%s:%s)/%s?charset=utf8mb4&amp;parseTime=True&amp;loc=Local",
                Config.Db.User,
                Config.Db.Password,
                Config.Db.Host,
                Config.Db.Port,
                Config.Db.Db,
        )
        fmt.Println("DSN:", dsn)

        var err error
        DB, err = gorm.Open(mysql.Open(dsn), &amp;gorm.Config{})
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to connect database: %w", err)
        }</span>

        // 获取底层 *sql.DB
        <span class="cov0" title="0">sqlDB, err := DB.DB()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get sql.DB: %w", err)
        }</span>

        // 测试连接
        <span class="cov0" title="0">if err := sqlDB.Ping(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to ping database: %w", err)
        }</span>

        <span class="cov0" title="0">log.Println("Successfully connected to database")
        return nil</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package controller

import (
        "LibraryManagement/config"
        "LibraryManagement/dto"
        "LibraryManagement/result"
        "LibraryManagement/service"
        "fmt"

        "github.com/gin-gonic/gin"
)

// AddBookController 添加书籍
func AddBookController(c *gin.Context) <span class="cov8" title="1">{
        bookInfoDTO := &amp;dto.BookInfoDTO{}
        err := c.BindJSON(bookInfoDTO)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">fmt.Println("收到请求---bookAdd: ", bookInfoDTO)
        service.NewBookService(c, config.DB).Add(bookInfoDTO)</span>
}

// DeleteBookController 删除书籍
func DeleteBookController(c *gin.Context) <span class="cov8" title="1">{
        var ids = make([]string, 0)
        ids = c.QueryArray("ids")
        fmt.Println("收到请求---Delete: ", ids)

        if len(ids) == 0 </span><span class="cov8" title="1">{
                result.Failed(c, result.RequiredCode, result.GetMessage(result.RequiredCode))
                return
        }</span>

        <span class="cov8" title="1">service.NewBookService(c, config.DB).Delete(ids)</span>
}

// UpdateBookController 更新书籍
func UpdateBookController(c *gin.Context) <span class="cov0" title="0">{
        bookUpdateDTO := &amp;dto.BookUpdateDTO{}
        err := c.BindJSON(bookUpdateDTO)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">fmt.Println("收到请求---bookUpdateDTO: ", bookUpdateDTO)
        service.NewBookService(c, config.DB).Update(bookUpdateDTO)</span>
}

// BookListController 批量查询
func BookListController(c *gin.Context) <span class="cov0" title="0">{
        bookSearchDTO := &amp;dto.BookSearchDTO{}
        err := c.BindJSON(bookSearchDTO)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">fmt.Println("收到请求---bookSearchDTO: ", bookSearchDTO)
        service.NewBookService(c, config.DB).List(bookSearchDTO)</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package controller

import (
        "LibraryManagement/config"
        "LibraryManagement/dto"
        "LibraryManagement/result"
        "LibraryManagement/service"
        "fmt"

        "github.com/gin-gonic/gin"
)

// LoginController 登入
func LoginController(c *gin.Context) <span class="cov8" title="1">{
        loginDTO := &amp;dto.LoginDTO{}
        err := c.BindJSON(loginDTO)
        if err != nil </span><span class="cov8" title="1">{
                result.Failed(c, result.FailedCode, "请求数据格式错误")
                return
        }</span>
        <span class="cov8" title="1">fmt.Println("收到请求---登入: ", loginDTO)
        service.NewUserService(c, config.DB).Login(loginDTO)</span>

}

// RegisterController 注册
func RegisterController(c *gin.Context) <span class="cov8" title="1">{
        registerDTO := &amp;dto.RegisterDTO{}
        err := c.BindJSON(registerDTO)
        if err != nil </span><span class="cov8" title="1">{
                result.Failed(c, result.FailedCode, "请求数据格式错误")
                return
        }</span>
        <span class="cov8" title="1">fmt.Println("收到请求---注册: ", registerDTO)
        service.NewUserService(c, config.DB).CreateUser(registerDTO)</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package dao

import (
        "LibraryManagement/dto"
        "LibraryManagement/entity"
        "LibraryManagement/vo"
        "errors"
        "strconv"

        "gorm.io/gorm"
)

func BookAddDAO(db *gorm.DB, dto *dto.BookInfoDTO) error <span class="cov8" title="1">{
        book := &amp;entity.Book{
                Title: dto.Title,
                Count: dto.Count,
                ISBN:  dto.ISBN,
        }

        return db.Create(book).Error
}</span>

func BookDeleteDAO(db *gorm.DB, idStr []string) error <span class="cov8" title="1">{
        ids := make([]uint, 0, len(idStr))
        for _, id := range idStr </span><span class="cov8" title="1">{
                uid, _ := strconv.ParseUint(id, 10, 64)
                ids = append(ids, uint(uid))
        }</span>
        <span class="cov8" title="1">return db.Delete(&amp;entity.Book{}, ids).Error</span>
}

// 数据库乐观锁更新
func BookUpdateDAO(db *gorm.DB, dto *dto.BookUpdateDTO) error <span class="cov8" title="1">{
        var book entity.Book
        err := db.Where("id = ?", dto.ID).First(&amp;book).Error
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        // 准备更新字段
        <span class="cov8" title="1">updates := map[string]interface{}{
                "title":   dto.Title,
                "count":   dto.Count,
                "isbn":    dto.ISBN,
                "version": book.Version + 1,
        }

        // 使用乐观锁更新
        result := db.Model(&amp;entity.Book{}).
                Where("id = ? AND version = ?", dto.ID, book.Version).
                Updates(updates)

        if result.Error != nil </span><span class="cov0" title="0">{
                return result.Error
        }</span>
        <span class="cov8" title="1">if result.RowsAffected == 0 </span><span class="cov8" title="1">{
                return errors.New("更新失败：数据已被其他用户修改，请刷新后重试")
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// TODO 考虑分页
func BookListDAO(db *gorm.DB, dto *dto.BookSearchDTO) (*[]vo.BookInfoVO, error) <span class="cov8" title="1">{
        dbSql := db.Model(&amp;entity.Book{})
        if dto.Title != "" </span><span class="cov8" title="1">{
                dbSql = dbSql.Where("title LIKE ?", "%"+dto.Title+"%")
        }</span>
        <span class="cov8" title="1">if dto.ISBN != "" </span><span class="cov8" title="1">{
                dbSql = dbSql.Where("isbn = ?", dto.ISBN)
        }</span>
        <span class="cov8" title="1">var books []vo.BookInfoVO
        dbSql.Find(&amp;books)
        return &amp;books, dbSql.Error</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package dao

import (
        "LibraryManagement/dto"
        "LibraryManagement/entity"
        "errors"

        "golang.org/x/crypto/bcrypt"
        "gorm.io/gorm"
)

type UserDAO interface {
        CreateUserDAO(db *gorm.DB, user *dto.RegisterDTO) error
        GetUserByUsernameDAO(db *gorm.DB, username string) (*entity.User, error)
        GetUserByIdDAO(db *gorm.DB, id uint) (*entity.User, error)
}

type userDAOImpl struct{}

// UserDao 全局实例
var UserDao UserDAO = &amp;userDAOImpl{}

// CreateUserDAO 创建用户（自动哈希密码）
func (d *userDAOImpl) CreateUserDAO(db *gorm.DB, user *dto.RegisterDTO) error <span class="cov0" title="0">{
        hashed, err := bcrypt.GenerateFromPassword([]byte(user.Password), bcrypt.DefaultCost)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">user.Password = string(hashed)
        return db.Create(user).Error</span>
}

// GetUserByUsernameDAO  根据用户名查找用户
func (d *userDAOImpl) GetUserByUsernameDAO(db *gorm.DB, username string) (*entity.User, error) <span class="cov0" title="0">{
        var user entity.User
        err := db.Where("username = ?", username).First(&amp;user).Error
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;user, nil</span>
}

// GetUserByIdDAO 根据 ID 查找用户
func (d *userDAOImpl) GetUserByIdDAO(db *gorm.DB, id uint) (*entity.User, error) <span class="cov0" title="0">{
        var user entity.User
        err := db.First(&amp;user, id).Error
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.New("用户不存在")
        }</span>
        <span class="cov0" title="0">return &amp;user, nil</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package main

import (
        "LibraryManagement/config"
        "LibraryManagement/router"
        "context"
        "errors"
        "log"
        "net/http"
        "os"
        "os/signal"
        "syscall"
        "time"
)

// 初始化配置，连接数据库
func init() <span class="cov0" title="0">{
        if err := config.LoadConfig("./config.yaml"); err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>

        <span class="cov0" title="0">err := config.SetupDBLink()
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }

}

// Gin 框架 Web 服务的优雅关闭（Graceful Shutdown）实现
func main() <span class="cov0" title="0">{
        gin := router.InitRouter()

        //创建HTTP服务器
        server := &amp;http.Server{
                Addr:    config.Config.Server.Port,
                Handler: gin,
        }

        //启动HTTP服务器
        go func() </span><span class="cov0" title="0">{
                if err := server.ListenAndServe(); err != nil &amp;&amp; !errors.Is(err, http.ErrServerClosed) </span><span class="cov0" title="0">{
                        log.Fatalf("listen: %s\n", err)
                }</span>
        }()

        //等待退出信号
        <span class="cov0" title="0">quit := make(chan os.Signal)
        signal.Notify(quit, syscall.SIGINT, syscall.SIGTERM)
        &lt;-quit
        log.Println("Shutdown Server ...")

        //创建超时上下文，Shutdown可以让未处理的连接在这个时间内关闭
        ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
        defer cancel()

        //停止HTTP服务器
        if err := server.Shutdown(ctx); err != nil </span><span class="cov0" title="0">{
                log.Fatal("Server Shutdown:", err)
        }</span>
        <span class="cov0" title="0">log.Println("Server exiting")</span>

}
</pre>
		
		<pre class="file" id="file7" style="display: none">package middleware

import (
        "LibraryManagement/utils"
        "net/http"

        "github.com/gin-gonic/gin"
)

// AuthMiddleware JWT 认证中间件
func AuthMiddleware(requiredRole string) gin.HandlerFunc <span class="cov0" title="0">{
        return func(c *gin.Context) </span><span class="cov0" title="0">{
                tokenStr := c.GetHeader("Authorization")
                if tokenStr == "" </span><span class="cov0" title="0">{
                        c.JSON(http.StatusUnauthorized, gin.H{"error": "未提供认证令牌"})
                        c.Abort()
                        return
                }</span>

                // Bearer &lt;token&gt;
                <span class="cov0" title="0">if len(tokenStr) &gt; 7 &amp;&amp; tokenStr[:7] == "Bearer " </span><span class="cov0" title="0">{
                        tokenStr = tokenStr[7:]
                }</span>

                <span class="cov0" title="0">claims, err := utils.ParseToken(tokenStr)
                if err != nil </span><span class="cov0" title="0">{
                        c.JSON(http.StatusUnauthorized, gin.H{"error": "无效或过期的令牌"})
                        c.Abort()
                        return
                }</span>

                // 角色权限校验
                <span class="cov0" title="0">if requiredRole != "" &amp;&amp; claims.Role != requiredRole </span><span class="cov0" title="0">{
                        c.JSON(http.StatusForbidden, gin.H{"error": "权限不足"})
                        c.Abort()
                        return
                }</span>

                // 将用户信息存入上下文
                <span class="cov0" title="0">c.Set("user_id", claims.UserID)
                c.Set("user_role", claims.Role)

                c.Next()</span>
        }
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package result

import "net/http"

// 定义状态码常量
const (
        SuccessCode  = http.StatusOK
        FailedCode   = http.StatusNotImplemented
        RequiredCode = http.StatusBadRequest
)

// 状态码与信息映射
var codeMessages = map[int]string{
        SuccessCode:  "成功",
        FailedCode:   "失败",
        RequiredCode: "缺少必要参数",
}

// GetMessage 返回状态码对应的提示信息
func GetMessage(code int) string <span class="cov0" title="0">{
        if msg, ok := codeMessages[code]; ok </span><span class="cov0" title="0">{
                return msg
        }</span>
        <span class="cov0" title="0">return "未知状态码"</span>
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package result

import (
        "net/http"

        "github.com/gin-gonic/gin"
)

type Result struct {
        Code    int         `json:"code"`
        Message string      `json:"message"`
        Data    interface{} `json:"data"`
}

func Success(c *gin.Context, data interface{}) <span class="cov0" title="0">{
        if data == nil </span><span class="cov0" title="0">{
                data = gin.H{}
        }</span>

        <span class="cov0" title="0">res := Result{}
        res.Code = SuccessCode
        res.Message = GetMessage(SuccessCode)
        res.Data = data

        c.JSON(http.StatusOK, res)</span>
}

func Failed(c *gin.Context, code int, message string) <span class="cov0" title="0">{
        res := Result{}
        res.Code = code
        res.Message = message
        res.Data = gin.H{}

        c.JSON(http.StatusOK, res)
}</span>
</pre>
		
		<pre class="file" id="file10" style="display: none">package router

import (
        "LibraryManagement/controller"
        "LibraryManagement/middleware"

        "github.com/gin-gonic/gin"
)

// InitRouter 初始化路由
func InitRouter() *gin.Engine <span class="cov0" title="0">{
        router := gin.Default()

        register(router)

        return router
}</span>

func register(router *gin.Engine) <span class="cov0" title="0">{

        // 公共路由（无需认证）
        auth := router.Group("/auth")
        </span><span class="cov0" title="0">{
                auth.POST("/register", controller.RegisterController)
                auth.POST("/login", controller.LoginController)
        }</span>

        // 受保护路由
        <span class="cov0" title="0">api := router.Group("/api")
        api.Use(middleware.AuthMiddleware("")) // 所有登录用户可访问
        </span><span class="cov0" title="0">{
                api.GET("/books/list", controller.BookListController)
                // TODO 借阅归还等
        }</span>

        // 管理员专用路由
        <span class="cov0" title="0">admin := router.Group("/admin")
        admin.Use(middleware.AuthMiddleware("admin")) // 仅管理员
        </span><span class="cov0" title="0">{
                admin.POST("/books/add", controller.AddBookController)
                admin.PUT("/books/update", controller.DeleteBookController)
                admin.DELETE("/books/delete", controller.UpdateBookController)
        }</span>

        //book := router.Group("/books")
        //{
        //        book.POST("/add", controller.AddBookController)
        //        book.DELETE("/delete", controller.DeleteBookController)
        //        book.PUT("/update", controller.UpdateBookController)
        //        book.GET("/list", controller.BookListController)
        //
        //}
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package service

import (
        "LibraryManagement/dao"
        "LibraryManagement/dto"
        "LibraryManagement/result"

        "github.com/gin-gonic/gin"
        "github.com/go-playground/validator/v10"
        "gorm.io/gorm"
)

type BookService interface {
        Add(dto *dto.BookInfoDTO)
        Delete(ids []string)
        Update(dto *dto.BookUpdateDTO)
        List(dto *dto.BookSearchDTO)
}

type bookServiceImpl struct {
        Ctx *gin.Context
        Db  *gorm.DB
}

func (b *bookServiceImpl) Add(dto *dto.BookInfoDTO) <span class="cov0" title="0">{
        // 验证器会根据结构体里写的 validate 标签，自动检查字段是否符合规则
        err := validator.New().Struct(dto)
        if err != nil </span><span class="cov0" title="0">{
                result.Failed(b.Ctx, result.RequiredCode, result.GetMessage(result.RequiredCode))
                return
        }</span>
        // TODO ISBN校验

        <span class="cov0" title="0">err = dao.BookAddDAO(b.Db, dto)
        if err != nil </span><span class="cov0" title="0">{
                result.Failed(b.Ctx, result.FailedCode, "书籍添加失败:"+err.Error())
                return
        }</span>

        <span class="cov0" title="0">result.Success(b.Ctx, "书籍添加成功")</span>

}

func (b *bookServiceImpl) Delete(ids []string) <span class="cov0" title="0">{
        err := dao.BookDeleteDAO(b.Db, ids)
        if err != nil </span><span class="cov0" title="0">{
                result.Failed(b.Ctx, result.FailedCode, "书籍删除失败:"+err.Error())
                return
        }</span>

        <span class="cov0" title="0">result.Success(b.Ctx, "书籍删除成功")</span>

}

// 数据库乐观锁更新
func (b *bookServiceImpl) Update(dto *dto.BookUpdateDTO) <span class="cov0" title="0">{
        // 验证器会根据结构体里写的 validate 标签，自动检查字段是否符合规则
        err := validator.New().Struct(dto)
        if err != nil </span><span class="cov0" title="0">{
                result.Failed(b.Ctx, result.RequiredCode, result.GetMessage(result.RequiredCode))
                return
        }</span>

        <span class="cov0" title="0">err = dao.BookUpdateDAO(b.Db, dto)
        if err != nil </span><span class="cov0" title="0">{
                result.Failed(b.Ctx, result.FailedCode, "书籍更新失败:"+err.Error())
                return
        }</span>

        <span class="cov0" title="0">result.Success(b.Ctx, "书籍更新成功")</span>
}

func (b *bookServiceImpl) List(dto *dto.BookSearchDTO) <span class="cov0" title="0">{
        // 验证器会根据结构体里写的 validate 标签，自动检查字段是否符合规则
        err := validator.New().Struct(dto)
        if err != nil </span><span class="cov0" title="0">{
                result.Failed(b.Ctx, result.RequiredCode, result.GetMessage(result.RequiredCode))
                return
        }</span>

        <span class="cov0" title="0">books, err := dao.BookListDAO(b.Db, dto)
        if err != nil </span><span class="cov0" title="0">{
                result.Failed(b.Ctx, result.FailedCode, "书籍查询失败:"+err.Error())
                return
        }</span>

        <span class="cov0" title="0">result.Success(b.Ctx, books)</span>
}

func NewBookService(ctx *gin.Context, db *gorm.DB) BookService <span class="cov0" title="0">{
        return &amp;bookServiceImpl{
                Ctx: ctx,
                Db:  db,
        }
}</span>
</pre>
		
		<pre class="file" id="file12" style="display: none">package service

import (
        "LibraryManagement/dao"
        "LibraryManagement/dto"
        "LibraryManagement/entity"
        "LibraryManagement/result"
        "LibraryManagement/utils"
        "LibraryManagement/vo"
        "errors"

        "github.com/gin-gonic/gin"
        "github.com/go-playground/validator/v10"
        "golang.org/x/crypto/bcrypt"
        "gorm.io/gorm"
)

type UserService interface {
        CreateUser(user *dto.RegisterDTO)
        Login(dto *dto.LoginDTO)
}

type userServiceImpl struct {
        Ctx *gin.Context
        Db  *gorm.DB
        Dao dao.UserDAO // 依赖注入
}

func (u userServiceImpl) CreateUser(user *dto.RegisterDTO) <span class="cov8" title="1">{
        if user.Role == "" </span><span class="cov0" title="0">{
                user.Role = "user"
        }</span>

        // 验证器会根据结构体里写的 validate 标签，自动检查字段是否符合规则
        <span class="cov8" title="1">err := validator.New().Struct(user)
        if err != nil </span><span class="cov0" title="0">{
                result.Failed(u.Ctx, result.RequiredCode, result.GetMessage(result.RequiredCode))
                return
        }</span>

        <span class="cov8" title="1">usernameDAO, err := u.Dao.GetUserByUsernameDAO(u.Db, user.Username)

        if err != nil &amp;&amp; !errors.Is(err, gorm.ErrRecordNotFound) </span><span class="cov0" title="0">{
                // 真正的数据库错误
                result.Failed(u.Ctx, result.FailedCode, "创建用户失败")
                return
        }</span>

        <span class="cov8" title="1">if usernameDAO != nil </span><span class="cov8" title="1">{
                // 用户已存在
                result.Failed(u.Ctx, result.FailedCode, "用户已存在")
                return
        }</span>

        <span class="cov8" title="1">err = u.Dao.CreateUserDAO(u.Db, user)
        if err != nil </span><span class="cov8" title="1">{
                result.Failed(u.Ctx, result.FailedCode, user.Role+"创建失败")
                return
        }</span>

        <span class="cov8" title="1">result.Success(u.Ctx, user.Role+"创建成功")</span>
}

func (u userServiceImpl) Login(dto *dto.LoginDTO) <span class="cov8" title="1">{
        user, err := u.Dao.GetUserByUsernameDAO(u.Db, dto.Username)
        if err != nil </span><span class="cov8" title="1">{
                result.Failed(u.Ctx, result.FailedCode, "用户名或密码错误")
                return
        }</span>

        // 验证密码
        <span class="cov8" title="1">if err := bcrypt.CompareHashAndPassword([]byte(user.PasswordHash), []byte(dto.Password)); err != nil </span><span class="cov8" title="1">{
                result.Failed(u.Ctx, result.FailedCode, "用户名或密码错误")
                return
        }</span>

        //生成 JWT Token
        <span class="cov8" title="1">token, err := utils.GenerateToken(user.ID, user.Role)
        if err != nil </span><span class="cov8" title="1">{
                result.Failed(u.Ctx, result.FailedCode, "系统错误")
                return
        }</span>

        <span class="cov8" title="1">result.Success(u.Ctx, &amp;vo.LoginVO{
                Token:  token,
                UserID: user.ID,
                Role:   user.Role,
        })</span>

}

// GetUserByID 获取用户信息（用于中间件或后续接口）
func (u userServiceImpl) GetUserByID(id uint) (*entity.User, error) <span class="cov0" title="0">{
        return dao.UserDao.GetUserByIdDAO(u.Db, id)
}</span>

var NewUserService = func(ctx *gin.Context, db *gorm.DB) UserService <span class="cov0" title="0">{
        return &amp;userServiceImpl{
                Ctx: ctx,
                Db:  db,
                Dao: dao.UserDao,
        }
}</span>
</pre>
		
		<pre class="file" id="file13" style="display: none">package utils

import (
        "errors"
        "time"

        "github.com/golang-jwt/jwt/v5"
)

var jwtSecret = []byte("key") // 建议从环境变量读取

type Claims struct {
        UserID uint   `json:"user_id"`
        Role   string `json:"role"`
        jwt.RegisteredClaims
}

// GenerateToken 生成 JWT Token
var GenerateToken = func(userID uint, role string) (string, error) <span class="cov8" title="1">{
        claims := &amp;Claims{
                UserID: userID,
                Role:   role,
                RegisteredClaims: jwt.RegisteredClaims{
                        ExpiresAt: jwt.NewNumericDate(time.Now().Add(24 * time.Hour)), // 24小时过期
                        IssuedAt:  jwt.NewNumericDate(time.Now()),
                        NotBefore: jwt.NewNumericDate(time.Now()),
                },
        }

        token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
        return token.SignedString(jwtSecret)
}</span>

// ParseToken 解析 JWT Token
func ParseToken(tokenStr string) (*Claims, error) <span class="cov8" title="1">{
        token, err := jwt.ParseWithClaims(tokenStr, &amp;Claims{}, func(token *jwt.Token) (interface{}, error) </span><span class="cov8" title="1">{
                return jwtSecret, nil
        }</span>)
        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if claims, ok := token.Claims.(*Claims); ok &amp;&amp; token.Valid </span><span class="cov8" title="1">{
                return claims, nil
        }</span>
        <span class="cov0" title="0">return nil, errors.New("invalid token")</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
